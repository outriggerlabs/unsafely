package unsafely

import (
	"encoding/json"
	"fmt"
	"reflect"
)

// JSONDecoder is a helper struct for reconstructing objects marshaled with
// JSONEncoder.
//
// See UnarshalJSON and JSONDecoder.Decode.
type JSONDecoder struct {
	config unmarshalJSONConfig

	// Map from pointer indices to their decoded values.
	pointerValues map[int]reflect.Value
}

// NewJSONDecoder creates a JSONDecoder with the given options.
//
// If the same JSONDecoder is used to unmarshal multiple values that share the
// same pointer reference numbers, e.g, they shared pointers and were marshaled
// with the same JSONEncoder, the output will share the same reconstructed
// pointer values.
func NewJSONDecoder(options ...UnmarshalJSONOption) *JSONDecoder {
	var config unmarshalJSONConfig
	for _, opt := range options {
		opt(&config)
	}

	return &JSONDecoder{
		config:        config,
		pointerValues: make(map[int]reflect.Value),
	}
}

// Decode deserializes a JSON string to the output value, including
// unexported fields.
//
// The output must be a pointer and the JSON string must have been generated by
// JSONEncoder.Encode or MarshalJSON.
//
// See the package notes for restrictions, limitations and options.
func (s *JSONDecoder) Decode(b []byte, outPtr any) error {
	var wrapper encodedJSONWrapper
	if err := json.Unmarshal(b, &wrapper); err != nil {
		return fmt.Errorf("JSONDecoder.Decode(): %w", err)
	}

	var (
		outPtrV = reflect.ValueOf(outPtr)
		outPtrT = outPtrV.Type()
	)

	if outPtrT.Kind() != reflect.Pointer {
		return fmt.Errorf("JSONDecoder.Decode(): value must be a pointer; received %v", outPtrT.Kind())
	}

	var (
		outV = outPtrV.Elem()
		outT = outV.Type()
	)

	encodedT, err := encodedTypeFor(outT)
	if err != nil {
		return fmt.Errorf("JSONDecoder.Decode(): %w", err)
	}

	var (
		encodedPtrV = reflect.New(encodedT)
		encodedV    = encodedPtrV.Elem()
	)

	// Unmarshal the JSON into the encoded value.
	if err := json.Unmarshal(wrapper.Value, encodedPtrV.Interface()); err != nil {
		return fmt.Errorf("JSONDecoder.Decode(): %w", err)
	}

	// Decode the encoded value into the output value.
	if err := s.decodeTo(encodedV, outV); err != nil {
		return fmt.Errorf("JSONDecoder.Decode(): %w", err)
	}

	return nil
}

// Copies from the exported value to the original value.
func (s *JSONDecoder) decodeTo(encodedV, decodedV reflect.Value) error {
	var (
		encodedT = encodedV.Type()
		decodedT = decodedV.Type()

		encodedKind = encodedT.Kind()
		decodedKind = decodedT.Kind()
	)

	// If the original decoded value implements json.Marshaler, then we used the
	// existing mechanism to marshal the value. We use the standard json.Unmarshal
	// function so we'll invoke the json.Unmarshaler mechanism, if defined.
	if decodedT.Implements(jsonMarshalerType) {
		encodedMessage := encodedV.Interface().(json.RawMessage)
		decodedPtr := decodedV.Addr().Interface()

		if err := json.Unmarshal(encodedMessage, decodedPtr); err != nil {
			return fmt.Errorf("decodeTo(): failed to unmarshal to type %s, raw message: %s, err: %w",
				decodedT.String(), string(encodedMessage), err,
			)
		}

		return nil
	}

	// We're decoding a pointerValue.
	if isPointerValueType(encodedT) {
		return s.decodeFromPointerValue(encodedV, decodedV)
	}

	// We're decoding an interfaceValue.
	if isInterfaceValueType(encodedT) {
		decodedOutputV, err := s.decodeFromInterfaceValue(encodedV)
		if err != nil {
			return fmt.Errorf("decodeTo(): %w", err)
		}

		// A zero value implies the interface was nil, which is the default value.
		if decodedOutputV != zeroValue {
			setField(decodedV, decodedOutputV)
		}

		return nil
	}

	// We're decoding a complexValue.
	if isComplexValueType(encodedT) {
		return decodeFromComplexValue(encodedV, decodedV)
	}

	if encodedKind != decodedKind {
		return fmt.Errorf(
			"decodeTo(): expected values to be the same kind; received %v and %v",
			encodedV.Type(), decodedV.Type(),
		)
	}

	if decodedKind == reflect.Map {
		if encodedV.IsNil() {
			return nil // The map in decodedV is nil by default.
		}

		decodedMap := reflect.MakeMapWithSize(decodedV.Type(), encodedV.Len())
		setField(decodedV, decodedMap)

		var (
			decodedKeyT = decodedV.Type().Key()
			decodedValT = decodedV.Type().Elem()
		)

		encodedKeyT, err := encodedTypeFor(decodedKeyT)
		if err != nil {
			return fmt.Errorf("decodeTo(): %w", err)
		}

		encodedMapIter := encodedV.MapRange()
		for encodedMapIter.Next() {
			var (
				encodedKey = encodedMapIter.Key()
				encodedVal = encodedMapIter.Value()

				decodedKey = encodedKey
			)

			// JSON does not support non-primitive keys (e.g, structs, pointers), so
			// we convert these map keys from JSON strings.
			if !isSimplePrimitive(decodedKeyT.Kind()) {
				var (
					encodedKeyBytes = []byte(encodedKey.String())
					encodedKeyPtrV  = reflect.New(encodedKeyT)
					encodedKeyPtr   = encodedKeyPtrV.Interface()
					encodedKeyV     = encodedKeyPtrV.Elem()
				)

				// Unmarshal and decode the key from the JSON string.
				if err := json.Unmarshal(encodedKeyBytes, encodedKeyPtr); err != nil {
					return fmt.Errorf("decodeTo(): %w", err)
				}

				decodedKeyV := reflect.New(decodedKeyT).Elem()
				if err := s.decodeTo(encodedKeyV, decodedKeyV); err != nil {
					return fmt.Errorf("decodeTo(): %w", err)
				}

				decodedKey = decodedKeyV
			}

			// Decode the map value.
			decodedVal := reflect.New(decodedValT).Elem()
			if err := s.decodeTo(encodedVal, decodedVal); err != nil {
				return fmt.Errorf("decodeTo(): %w", err)
			}

			// Set the key and value on the decoded map.
			decodedMap.SetMapIndex(decodedKey, decodedVal)
		}

		return nil
	}

	if encodedKind == reflect.Struct {
		return copyStruct(s.decodeTo, encodedV, decodedV, false /* isEncode */)
	}

	return copyCommon(s.decodeTo, encodedV, decodedV)
}
